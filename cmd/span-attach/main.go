// span-wip -db amsl.db < in > out
//
// For each record:
//
// [ ] select rows from db (sid, mc, tcid)
// [ ] if there is a holdingfile, and not cached, download, cache, parse and cache it
// [ ] match against holdingfile
// [ ] collect all ISIL and attach them (or just print id and isil)
// [ ] parallelize by copying the database (sqlite3 is single threaded), e.g. 4x NumCPU of the like
//
// Also, try to get rid of span-freeze by using some locally cached files (with
// expiry date).
package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"time"

	_ "github.com/mattn/go-sqlite3"

	"github.com/jmoiron/sqlx"
	"github.com/miku/span/formats/finc"
)

var (
	force  = flag.Bool("f", false, "force all external referenced links to be downloaded")
	dbFile = flag.String("db", "", "path to an sqlite3 file generated by span-amsl-discovery -db file.db ...")
)

// ConfigRow decribing a single entry (e.g. an attachment request).
type ConfigRow struct {
	ShardLabel                     string
	ISIL                           string
	SourceID                       string
	TechnicalCollectionID          string
	MegaCollection                 string
	HoldingsFileURI                string
	HoldingsFileLabel              string
	LinkToHoldingsFile             string
	EvaluateHoldingsFileForLibrary string
	ContentFileURI                 string
	ContentFileLabel               string
	LinkToContentFile              string
	ExternalLinkToContentFile      string
	ProductISIL                    string
	DokumentURI                    string
	DokumentLabel                  string
}

// Labeler updates an intermediate schema document.
// We need mostly: ISIL, SourceID, MegaCollection, TechnicalCollectionID, HoldFileURI,
// EvaluateHoldingsFileForLibrary
type Labeler struct {
	dbFile string
	db     *sqlx.DB

	// Cache attachment results here.
	cache map[string][]string
}

func (l *Labeler) open() error {
	if l.db != nil {
		return nil
	}
	dsn := fmt.Sprintf("%s?ro=1", l.dbFile)
	log.Printf("using %s", dsn)
	db, err := sqlx.Connect("sqlite3", dsn)
	if err != nil {
		return err
	}
	l.db = db
	return nil
}

// Label updates document in place.
func (l *Labeler) Label(doc *finc.IntermediateSchema) error {
	if err := l.open(); err != nil {
		return err
	}
	// Top level cache for (sid, collection, tcid, hfeval, hflink).
	if l.cache == nil {
		l.cache = make(map[string][]string)
	}
	key := fmt.Sprintf("%s-%s", doc.SourceID, strings.Join(doc.MegaCollections, "."))
	if _, ok := l.cache[key]; ok {
		// log.Printf("cache hit: %s", key)
		// Reuse results.
		return nil
	}
	q, args, err := sqlx.In(`
		SELECT isil, sid, tcid, mc, hflink, hfeval FROM amsl
		WHERE sid = ? AND (mc IN (?) OR tcid IN (?))
	`, doc.SourceID, doc.MegaCollections, doc.MegaCollections)
	if err != nil {
		log.Println(doc)
		return err
	}
	rows, err := l.db.Query(q, args...)
	if err != nil {
		return err
	}
	var r = 0
	for rows.Next() {
		r++
		var cr ConfigRow
		err = rows.Scan(&cr.ISIL, &cr.SourceID, &cr.TechnicalCollectionID,
			&cr.MegaCollection, &cr.LinkToHoldingsFile, &cr.EvaluateHoldingsFileForLibrary)
		if err != nil {
			return err
		}
		switch {
		case cr.EvaluateHoldingsFileForLibrary == "yes" && cr.LinkToHoldingsFile != "":
			// Cache holding file as well.
			// log.Printf("evaluate HF")
		default:
			// Move on, or other cases?
			// log.Printf("ok")
		}
	}
	// log.Printf("found %d rows", r)
	l.cache[key] = []string{"fake"}
	// log.Printf("updated cache: %d", len(l.cache))
	return nil
}

func main() {
	flag.Parse()
	if *dbFile == "" {
		log.Fatal("we need a configuration database")
	}
	var (
		labeler = &Labeler{dbFile: *dbFile}
		br      = bufio.NewReader(os.Stdin)
		i       = 0
		started = time.Now()
	)
	for {
		if i%10000 == 0 {
			log.Printf("%d %0.2f", i, float64(i)/time.Since(started).Seconds())
		}
		b, err := br.ReadBytes('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}
		var doc finc.IntermediateSchema // TODO: try reduced schema
		if err := json.Unmarshal(b, &doc); err != nil {
			log.Fatal(err)
		}
		if err := labeler.Label(&doc); err != nil {
			log.Fatal(err)
		}
		i++
	}
}
