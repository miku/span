// span-crossref-members fetches crossref members api. It will merely paginate
// through the api responses and will output one response per line.  Create
// mapping from DOI to name: span-crossref-members | jq -rc '.message.items[].prefix[] |
// {(.value|tostring): .name}' | jq -s add > assets/crossref/members.json
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/miku/span"
)

// MembersResponse from api.crossref.org/member, generated by JSONGen, use offset to paginate.
type MembersResponse struct {
	Message struct {
		Items []struct {
			Breakdowns interface{} `json:"breakdowns"`
			Counts     struct {
				BackfileDois int64 `json:"backfile-dois"`
				CurrentDois  int64 `json:"current-dois"`
				TotalDois    int64 `json:"total-dois"`
			} `json:"counts"`
			CountsType   interface{} `json:"counts-type"`
			Coverage     interface{} `json:"coverage"`
			CoverageType interface{} `json:"coverage-type"`
			Flags        struct {
				Deposits                           bool `json:"deposits"`
				DepositsAbstractsBackfile          bool `json:"deposits-abstracts-backfile"`
				DepositsAbstractsCurrent           bool `json:"deposits-abstracts-current"`
				DepositsAffiliationsBackfile       bool `json:"deposits-affiliations-backfile"`
				DepositsAffiliationsCurrent        bool `json:"deposits-affiliations-current"`
				DepositsArticles                   bool `json:"deposits-articles"`
				DepositsAwardNumbersBackfile       bool `json:"deposits-award-numbers-backfile"`
				DepositsAwardNumbersCurrent        bool `json:"deposits-award-numbers-current"`
				DepositsFundersBackfile            bool `json:"deposits-funders-backfile"`
				DepositsFundersCurrent             bool `json:"deposits-funders-current"`
				DepositsLicensesBackfile           bool `json:"deposits-licenses-backfile"`
				DepositsLicensesCurrent            bool `json:"deposits-licenses-current"`
				DepositsOpenReferencesBackfile     bool `json:"deposits-open-references-backfile"`
				DepositsOpenReferencesCurrent      bool `json:"deposits-open-references-current"`
				DepositsOrcidsBackfile             bool `json:"deposits-orcids-backfile"`
				DepositsOrcidsCurrent              bool `json:"deposits-orcids-current"`
				DepositsReferencesBackfile         bool `json:"deposits-references-backfile"`
				DepositsReferencesCurrent          bool `json:"deposits-references-current"`
				DepositsResourceLinksBackfile      bool `json:"deposits-resource-links-backfile"`
				DepositsResourceLinksCurrent       bool `json:"deposits-resource-links-current"`
				DepositsSimilarityCheckingBackfile bool `json:"deposits-similarity-checking-backfile"`
				DepositsSimilarityCheckingCurrent  bool `json:"deposits-similarity-checking-current"`
				DepositsUpdatePoliciesBackfile     bool `json:"deposits-update-policies-backfile"`
				DepositsUpdatePoliciesCurrent      bool `json:"deposits-update-policies-current"`
			} `json:"flags"`
			Id                  int64    `json:"id"`
			LastStatusCheckTime int64    `json:"last-status-check-time"`
			Location            string   `json:"location"`
			Names               []string `json:"names"`
			Prefix              []struct {
				Name                string `json:"name"`
				PublicReferences    bool   `json:"public-references"`
				ReferenceVisibility string `json:"reference-visibility"`
				Value               string `json:"value"`
			} `json:"prefix"`
			Prefixes    []string `json:"prefixes"`
			PrimaryName string   `json:"primary-name"`
			Tokens      []string `json:"tokens"`
		} `json:"items"`
		ItemsPerPage int64 `json:"items-per-page"`
		Query        struct {
			SearchTerms interface{} `json:"search-terms"`
			StartIndex  int64       `json:"start-index"`
		} `json:"query"`
		TotalResults int64 `json:"total-results"`
	} `json:"message"`
	MessageType    string `json:"message-type"`
	MessageVersion string `json:"message-version"`
	Status         string `json:"status"`
}

var (
	offset     = flag.Int("offset", 0, "offset")
	rows       = flag.Int("rows", 20, "rows to fetch per request")
	base       = flag.String("base", "http://api.crossref.org/members", "base url")
	sleep      = flag.Duration("sleep", 1*time.Second, "time to sleep between requests")
	email      = flag.String("email", "", "optional email for api etiquette")
	silent     = flag.Bool("q", false, "suppress logging output")
	version    = flag.Bool("version", false, "output version")
	retryCount = flag.Int("retry", 3, "retry count on HTTP 500 and similar errors")
)

func main() {
	flag.Parse()

	if *silent {
		log.SetOutput(ioutil.Discard)
	}
	if *version {
		fmt.Println(span.AppVersion)
		os.Exit(0)
	}

	var buf bytes.Buffer

	for {
		v := url.Values{}
		v.Add("offset", fmt.Sprintf("%d", *offset))
		v.Add("rows", fmt.Sprintf("%d", *rows))
		if *email != "" {
			v.Add("email", *email)
		}

		link := fmt.Sprintf("%s?%s", *base, v.Encode())

		// Why: Because an HTTP 500 appeared.
		var (
			retries int
			resp    *http.Response
			err     error
		)
		for {
			if retries > *retryCount {
				log.Fatal("retry count exceeded")
			}
			log.Println(link)
			resp, err = http.Get(link)
			if err != nil {
				log.Fatal(err)
			}
			defer resp.Body.Close()
			if resp.StatusCode < 400 {
				break
			}
			log.Printf("request failed with HTTP %d", resp.StatusCode)
			time.Sleep(2 * time.Second)
			retries++
		}

		tee := io.TeeReader(resp.Body, &buf)

		// Need to peek into offset and total results.
		dec := json.NewDecoder(tee)
		var mr MembersResponse
		if err := dec.Decode(&mr); err != nil {
			log.Printf("decode failed: %s", buf.String())
			log.Fatal(err)
		}
		if mr.Status != "ok" {
			log.Fatalf("status not ok: %s", mr.Status)
		}
		if mr.Message.Query.StartIndex >= mr.Message.TotalResults {
			break
		}
		log.Printf("done: %d/%d", mr.Message.Query.StartIndex, mr.Message.TotalResults)

		time.Sleep(*sleep)
		*offset = *offset + *rows

		fmt.Println(buf.String())
		buf.Truncate(0)
	}
}
